//
//  Scene.cpp
//  gaspunk 2.0
//
//  Created by Frank Collebrusco on 6/1/22.
//

#include "Scene.h"

void Scene::Destroy(){
    for (auto ent : sEnts){
        ent.second->Destroy(this);
        delete ent.second;
    }
    sRegistry.clear();
    
}
void Scene::AddMesh(string name, MeshDetails mds){
    sMeshes[name] = mds;
}
void Scene::AddTexture(string name, int slot){
    sTextures[name] = slot;
}

void Scene::outputMat4(mat4 m){
    for (int i = 0; i < 4; i++){
        for (int j = 0; j < 4; j++){
            cout << m[i][j] << " ";
        }
        cout << endl << endl;
    }
    
}

glm::mat4 Scene::genModelMat(Transform t){//, glm::mat4 *m){
    glm::mat4 m;
    m = glm::mat4(1.0);
    m = glm::translate(m, t.pos);
    m = glm::rotate(m, glm::radians(t.rotation.x), glm::vec3(1.0, 0.0, 0.0));
    m = glm::rotate(m, glm::radians(t.rotation.y), glm::vec3(0.0, 1.0, 0.0));
    m = glm::rotate(m, glm::radians(t.rotation.z), glm::vec3(0.0, 0.0, 1.0));
    m = glm::scale(m, t.scale);
    m = glm::translate(m, t.anchor);

    //std::cout << t.pos.x << ", " << t.pos.y << std::endl;
    return m;
}

Scene::Scene(GLFWwindow * win, ScrollDataLocations scr) //: interface(win)
{
//    win = window;
    lrbtMat[0] = glm::vec4(-0.5f, 0.5f, 0, 0);
    lrbtMat[1] = glm::vec4(0, 0, -0.5f, 0.5f);
    scroll.scrollnanosLoc = scr.scrollnanosLoc;
    scroll.scrollxLoc = scr.scrollxLoc;
    scroll.scrollyLoc = scr.scrollyLoc;
    //TODO move shader compilation somewhere?
    sShaders["default"] = Shader("vert shader", "frag shader");
    sShaders["UI"] = Shader("vert shader UI", "frag shader UI");

    
}

void Scene::Init(){
    //INIT & SPAWN CAMERA
    sEnts["camera"] = new OCamera(this); //TODO: GARBAGE COLLECT THESE
    sEnts["camera"]->Spawn(Transform(glm::vec3(0.0, 0.0, 10.0), glm::vec3(10.0), glm::vec3(0.0)));
    
    //INIT & SPAWN HERO!
    sEnts["hero"] = new Hero(this);
    sEnts["hero"]->Spawn(Transform(glm::vec3(0.0), glm::vec3(1), glm::vec3(0.0)));
    
    //INIT & SPAWN CAR
    sEnts["car"] = new Vehicle(this);
    sEnts["car"]->Spawn(Transform(glm::vec3(4.0, 2.0, 0.0), glm::vec3(1.0), glm::vec3(0.0, 0.0, 45.0), glm::vec3(0.0, 0.0, 0.0)));
    
    sEnts["cursor"] = new Cursor(this);
    sEnts["cursor"]->Spawn(Transform(glm::vec3(0.0)));
    
    sEnts["gauge"] = new Gauge(this);
    sEnts["gauge"]->Spawn(Transform(glm::vec3(-1.5, -1, 0.0), glm::vec3(0.2)));
    
}

void Scene::Update(float dt){
//    interface.update();
    Script(dt);
    Action(dt);
    Physics(dt);
    Camera(dt);
}

void Scene::Script(float dt){
    auto ents = sRegistry.view<ScriptComponent>();
    for (auto ent : ents){
        auto& scrip = sRegistry.get<ScriptComponent>(ent);
        if (scrip){
            scrip.scrip->onUpdate(this, dt);
        }
    }
}

void Scene::Action(float dt){
    for (auto ent : sEnts){
        auto acts = ent.second->takeTurn();
        if (acts.size() != 0){
//            cout << "Performing action...\n";
            for (auto action : acts){
                action->perform(this, dt);
                delete action; //TODO: mandatory destructor
            }
        }
    }
}

void Scene::Physics(float dt){
    //VELOS
    //DEBUG dont know if these up on the fly
    auto velocomps = sRegistry.view<VelocityComponent>();
    auto tobDisplaced = sRegistry.view<DisplaceComponent>();
    int i = 0;
//    while (tobDisplaced.size() > 0 || velocomps.size() > 0 || i > 5) {
        for (auto  entity : velocomps){
            auto [t, v, d] = sRegistry.try_get<TransformComponent, VelocityComponent, DisplaceComponent>(entity);
            //TODO: check for collisions, bounding entswCollision, noclip, etc
            //maybe kinetic comp instead of velo? velo and acc in one?
            if (d){
                d->displace += v->velocity.pos;
                t->trans.scale += v->velocity.scale;
                d->displace += v->velocity.rotation;
            
            } else {
                sRegistry.emplace<DisplaceComponent>(entity, v->velocity.pos, v->velocity.rotation.z);
            }
        }
        //DISPLACE
        //TB MEANS TO BE DISPLACED
        //E MEANS ENVIRONMENTAL (ENTS GATHERED FROM SCENE IN SURROUNDINGS)
    auto entswCollision = sRegistry.view<BoxComponent>();

//    while (tobDisplaced.size() != 0 && entswCollision.size() != 0 && i < 5) {
        for (auto  etobDisplaced : tobDisplaced){
                    auto [transTB, dispTB, boxTB] = sRegistry.try_get<TransformComponent, DisplaceComponent, BoxComponent>(etobDisplaced);
                    //TODO: check for collisions, bounding entswCollision, noclip, etc
                    if (transTB && boxTB){
                        bool free = true;
                        bool deflect = false;
                        glm::vec2 callertoObj;
                        glm::vec3 deflection;
            
                        for (auto entwCollision : entswCollision){
                            if (entwCollision != etobDisplaced){
                                auto [transE, boxE] = sRegistry.try_get<TransformComponent, BoxComponent>(entwCollision);
                                glm::vec3 callerBoxCenter = glm::vec3(transTB->trans.pos.x + boxTB->pos.x,
                                                                      transTB->trans.pos.y + boxTB->pos.y,
                                                                      transTB->trans.pos.z);
                                glm::vec3 objBoxCenter = glm::vec3(transE->trans.pos.x + boxE->pos.x,
                                                                   transE->trans.pos.y + boxE->pos.y,
                                                                   transE->trans.pos.z);
                                callertoObj = glm::vec2(objBoxCenter.x - callerBoxCenter.x, objBoxCenter.y - callerBoxCenter.y);
                                float collangle = glm::degrees(fmath::vectorToAngle(glm::vec3(callertoObj, 0.0)));
                                float dispangle = glm::degrees(fmath::vectorToAngle(dispTB->displace));
                                float colltoDisp = fmath::smallestAngleFrom(collangle,
                                                                            dispangle);
                                    //TODO: all of these need to filter entities to collide check to within specified range which will be max boxcomp size to avoid looping over entities across the world from each other
                                if (boxTB->type == 'c' && boxE->type == 'c'){
//BOX TO BE AND BOX ENVIRONMENT ARE BOTH RADIAL, CHECK ACCORDINGLY
                                    bool cc = (glm::length((callerBoxCenter + dispTB->displace) - objBoxCenter) - boxE->rad - boxTB->rad) < 0;
                                    if (cc){
                                        free = false;
                                        int sign = 1;
                                        if (colltoDisp < 0) {sign = -1;}
                                        glm::vec3 V = fmath::angleToVector(collangle + (90 * sign));
                                        float udotv = (dispTB->displace.x * V.x) + (dispTB->displace.y * V.y);
                                        float magvsq = glm::length(V) * glm::length(V);
                                        deflection = V * (udotv / magvsq);
                                            //TODO: check deflect against all other ents once more
                                        deflect = true;
                                    }
            
                                } else if (boxTB->type == 'c' && boxE->type == 's') {
//BOX TO BE IS RADIAL, BOX E IS RECTANGULAR, CHECK ACCORDINGLY
                                    auto objToCaller = (callertoObj * -1.0f) + glm::vec2(dispTB->displace.x, dispTB->displace.y);
                                    glm::vec3 objToCaller_r = glm::vec3(fmath::rotateVector(objToCaller, -transE->trans.rotation.z), 0.0);
                                    bool cs = ((glm::abs(objToCaller_r.x) < ((boxE->size.x / 2.0) + boxTB->rad)) &&
                                                (glm::abs(objToCaller_r.y) < ((boxE->size.y / 2.0) + boxTB->rad)));
            
                                    if (cs){
                                        free = false;
                                        //deflect...
                                        glm::vec3 V;
                                        bool hittingWSide = (((boxE->size.x / 2.0) + boxTB->rad)) - (glm::abs(objToCaller_r.x)) <
                                        (((boxE->size.y / 2.0) + boxTB->rad)) - (glm::abs(objToCaller_r.y));
                                        if (hittingWSide){
                                            V = glm::vec3(0.0, (-2.0 * (objToCaller_r.x < 0)) + 1.0, 0.0);
                                        } else {
                                            V = glm::vec3((-2.0 * (objToCaller_r.y < 0)) + 1.0, 0.0, 0.0);
                                        }
                                        V = fmath::rotateVector(V, transE->trans.rotation.z);
                                        cout << "V: " << V.x << ", " << V.y << endl;
                                        float udotv = (dispTB->displace.x * V.x) + (dispTB->displace.y * V.y);
                                        deflection = V * udotv;
                                        cout << "deflection: " << deflection.x << ", " << deflection.y << "\n";
                                        sDiags["deflect"] = glm::degrees(fmath::vectorToAngle(deflection));
                                        cout << "def angle: " << sDiags["deflect"] << endl;
                                        deflect = true;
                                    }
            
                                } else if (boxTB->type == 's' && boxE->type == 's') {
//BOX TO BE AND BOX E ARE BOTH RECTANGULAR, CHECK ACCORDINGLY
            
                                } else if (boxTB->type == 's' && boxE->type == 'c') {
//BOX TO BE IS RECTANGULAR, BOX E IS RADIAL, CHECK ACCORDINGLY
                                }

                            }
            
                        }
                        if (free){
                            transTB->trans.pos += (dispTB->displace);
//                            sRegistry.remove<DisplaceComponent>(etobDisplaced);
                            
                            
//                            transTB->trans.pos += (dispTB->displace);
                            cout << dispTB->displace.x << " , " << dispTB->displace.y << endl;
                        } else if (deflect){
                            sRegistry.replace<DisplaceComponent>(etobDisplaced, deflection);
                            
                            transTB->trans.pos += deflection;
                            
                        } else {
//                            sRegistry.remove<DisplaceComponent>(etobDisplaced);
                        }
                    }
                    sRegistry.remove<DisplaceComponent>(etobDisplaced);

        }
        i++;
//    }
    
}

void Scene::Camera(float dt){
    //TODO: only works w orthos rn
    //look through all cameras w tforms to get an enabled one
    //camera MUST HAVE TFORM to be considered here
    //TODO: enable(cameracomp cam) func somewhere
    auto validCameras = sRegistry.group<OrthoCameraComponent>(entt::get<TransformComponent>);
    for (entt::entity cam : validCameras){
        bool flag = false;
        //check if active
        const auto&[cameraComp, transformComp] = validCameras.get<OrthoCameraComponent, TransformComponent>(cam);
        if (cameraComp.enable){  //TODO: set up entt observer to check this so that currcam changes only up when necc (probly rare)
            currCam = cam;
            flag = true;
        }
        if (!flag){
            cout << "no valid camera enabled in current scene registry!\n";
        }
        auto [currCamT, currCamC] = sRegistry.get<TransformComponent, OrthoCameraComponent>(currCam);
        //link cam and trans
        currCamC.pos = currCamT.trans.pos;
        
        glm::vec3 target = currCamC.pos + currCamC.look;
        currCamC.view = lookAt(currCamC.pos, target, currCamC.up);
        
        glm::vec2 orthoDims = glm::vec2(currCamC.viewWidth, currCamC.viewWidth / window.aspect);

        glm::vec4 lrbt = (lrbtMat * orthoDims);

        orthoDims.y = orthoDims.x / window.aspect;
        lrbt = (lrbtMat * orthoDims);
        currCamC.proj = glm::ortho(lrbt.x, lrbt.y, lrbt.z, lrbt.w, currCamC.near, currCamC.far);

        //UPLOAD VIEWS AND PROJS TO ALL SHADERS
        currCamProj = currCamC.proj;
        currCamView = currCamC.view;
        currCamPos = currCamC.pos;
        currCamWorldFrame = orthoDims;
        //TODO: organize which shaders get what
        
//        for (auto shad : sShaders){
//            shad.second.bind();
//            shad.second.uMat4("uView", currCamC.view);
//            shad.second.uMat4("uProj", currCamC.proj);
//        }
        
       
        sShaders["default"].bind();
        sShaders["default"].uMat4("uView", currCamC.view);
        sShaders["default"].uMat4("uProj", currCamC.proj);
        
        glm::mat4 viewUI = lookAt(glm::vec3(0.0, 0.0, 10.0), glm::vec3(0.0), glm::vec3(0.0, 1.0, 0.0));
        glm::mat4 projUI = glm::ortho((-2.0),
                                      (2.0),
                                      (-2.0 / window.aspect),
                                      (2.0 / window.aspect),
                                      0.0001,
                                      1000.0);
        sShaders["UI"].bind();
        sShaders["UI"].uMat4("uView", viewUI);
        sShaders["UI"].uMat4("uProj", projUI);


        

    }

}

void Scene::DrawSystemRender(){
    auto validRenders = sRegistry.group<MeshComponent>(entt::get<TransformComponent,
                                                                 DrawOrderComponent,
                                                                 TextureComponent,
                                                                 ShaderComponent>);
    for (int i = 0; i < 9; i++){
        for(auto entity : validRenders){
            //DEBUG: this doesnt check if any valid renders present and will bad access in that case
            auto [mesh, trans, order, tex, shad] = validRenders.get(entity);
            if (order.priority == i){
                sShaders[shad].bind();
                sShaders[shad].uVec2("uRes", window.frame);
//                sShaders[shad].uFloat("uTime", window.time);
                sShaders[shad].uVec2("uMouse", window.mouse.position);
                sShaders[shad].uMat4("uModel", glm::scale(genModelMat(trans.trans),
                                                          glm::vec3(tex.spritePixW / 16.0,
                                                                    tex.spritePixH / 16.0,
                                                                    1.0)));
                sShaders[shad].uInt("uTexture", tex.slot);
                sShaders[shad].uInt("uSpritePixW", tex.spritePixW);
                sShaders[shad].uInt("uSpritePixH", tex.spritePixH);
                sShaders[shad].uVec2("uSpriteSheetCoords", tex.sheetPos);
          
                DrawMesh(&mesh.mesh);
            }
        }
    }
}

glm::vec3 Scene::mouseToWorldSpace(glm::vec2 pm){
    glm::vec3 pworld;
    glm::vec2 pmouse = pm;
    pmouse.x /= window.frame.x;
    pmouse.x *= 2;
    pmouse.x -= 1;
    pmouse.y /= window.frame.y;
    pmouse.y *= 2;
    pmouse.y -= 1;
    pmouse.y *= -1;
    
    pworld.x = currCamPos.x + (pmouse.x * (currCamWorldFrame.x / 2));
    pworld.y = currCamPos.y + (pmouse.y * (currCamWorldFrame.y / 2));
//    cout << pworld.x << ", " << pworld.y << "\n";

    
    return pworld;
}
glm::vec2 Scene::worldToMouseSpace(glm::vec3 pworld){
    glm::vec2 pmouse;
    glm::mat4 model = genModelMat(Transform(pworld));
    pmouse = currCamProj * (currCamView * (model * vec4(pworld, 1.0f)));
    pmouse.x = (pmouse.x + 1) / 2;
    pmouse.y = (pmouse.y + 1) / 2;
    pmouse.x *= window.frame.x;
    pmouse.y *= window.frame.y;
    return pmouse;
}

glm::vec2 Scene::worldToScreenSpace(glm::vec3 pworld){
    glm::vec2 pscreen;
    glm::mat4 model = genModelMat(Transform(pworld));
    pscreen = currCamProj * (currCamView * (model * vec4(pworld, 1.0f)));
    return pscreen;
}

glm::vec3 Scene::screenToWorldSpace(glm::vec2 s){
    glm::vec3 pworld;
    glm::vec2 pscreen = s;
//    pscreen.x /= window.frame.x;
//    pscreen.x *= 2;
//    pscreen.x -= 1;
//    pscreen.y /= window.frame.y;
//    pscreen.y *= 2;
//    pscreen.y -= 1;
//    pscreen.y *= -1;
    
    pworld.x = currCamPos.x + (pscreen.x * (currCamWorldFrame.x / 2));
    pworld.y = currCamPos.y + (pscreen.y * (currCamWorldFrame.y / 2));
//    cout << pworld.x << ", " << pworld.y << "\n";

    
    return pworld;
}

//void removePointerComponent(entt::registry &reg, entt::entity ent){
////    auto pcomp
//}

entt::entity Scene::getEntityID(string name){
    return sEnts[name]->getID();
}


//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================



//
//  Scene.cpp
//  gaspunk 2.0
//
//  Created by Frank Collebrusco on 6/1/22.
//

#include "Scene.h"

void Scene::Destroy(){
    for (auto ent : sEnts){
        ent.second->Destroy(this);
        delete ent.second;
    }
    sRegistry.clear();
    
}
void Scene::AddMesh(string name, MeshDetails mds){
    sMeshes[name] = mds;
}
void Scene::AddTexture(string name, int slot){
    sTextures[name] = slot;
}

void Scene::outputMat4(mat4 m){
    for (int i = 0; i < 4; i++){
        for (int j = 0; j < 4; j++){
            cout << m[i][j] << " ";
        }
        cout << endl << endl;
    }
    
}

glm::mat4 Scene::genModelMat(Transform t){//, glm::mat4 *m){
    glm::mat4 m;
    m = glm::mat4(1.0);
    m = glm::translate(m, t.pos);
    m = glm::rotate(m, glm::radians(t.rotation.x), glm::vec3(1.0, 0.0, 0.0));
    m = glm::rotate(m, glm::radians(t.rotation.y), glm::vec3(0.0, 1.0, 0.0));
    m = glm::rotate(m, glm::radians(t.rotation.z), glm::vec3(0.0, 0.0, 1.0));
    m = glm::scale(m, t.scale);
    m = glm::translate(m, t.anchor);

    //std::cout << t.pos.x << ", " << t.pos.y << std::endl;
    return m;
}

Scene::Scene(GLFWwindow * win, ScrollDataLocations scr) //: interface(win)
{
//    win = window;
    lrbtMat[0] = glm::vec4(-0.5f, 0.5f, 0, 0);
    lrbtMat[1] = glm::vec4(0, 0, -0.5f, 0.5f);
    scroll.scrollnanosLoc = scr.scrollnanosLoc;
    scroll.scrollxLoc = scr.scrollxLoc;
    scroll.scrollyLoc = scr.scrollyLoc;
    //TODO move shader compilation somewhere?
    sShaders["default"] = Shader("vert shader", "frag shader");
    sShaders["UI"] = Shader("vert shader UI", "frag shader UI");

    
}

void Scene::Init(){
    //INIT & SPAWN CAMERA
    sEnts["camera"] = new OCamera(this); //TODO: GARBAGE COLLECT THESE
    sEnts["camera"]->Spawn(Transform(glm::vec3(0.0, 0.0, 10.0), glm::vec3(10.0), glm::vec3(0.0)));
    
    //INIT & SPAWN HERO!
    sEnts["hero"] = new Hero(this);
    sEnts["hero"]->Spawn(Transform(glm::vec3(0.0), glm::vec3(1), glm::vec3(0.0)));
    
    //INIT & SPAWN CAR
    sEnts["car"] = new Vehicle(this);
    sEnts["car"]->Spawn(Transform(glm::vec3(4.0, 2.0, 0.0), glm::vec3(1.0), glm::vec3(0.0, 0.0, 45.0), glm::vec3(0.0, 0.0, 0.0)));
    
    sEnts["cursor"] = new Cursor(this);
    sEnts["cursor"]->Spawn(Transform(glm::vec3(0.0)));
    
    sEnts["gauge"] = new Gauge(this);
    sEnts["gauge"]->Spawn(Transform(glm::vec3(-1.5, -1, 0.0), glm::vec3(0.2)));
    
}

void Scene::Update(float dt){
//    interface.update();
    Script(dt);
    Action(dt);
    Physics(dt);
    Camera(dt);
}

void Scene::Script(float dt){
    auto ents = sRegistry.view<ScriptComponent>();
    for (auto ent : ents){
        auto& scrip = sRegistry.get<ScriptComponent>(ent);
        if (scrip){
            scrip.scrip->onUpdate(this, dt);
        }
    }
}

void Scene::Action(float dt){
    for (auto ent : sEnts){
        auto acts = ent.second->takeTurn();
        if (acts.size() != 0){
//            cout << "Performing action...\n";
            for (auto action : acts){
                action->perform(this, dt);
                delete action; //TODO: mandatory destructor
            }
        }
    }
}

void Scene::Physics(float dt){
    //VELOS
    //DEBUG dont know if these up on the fly
    auto velocomps = sRegistry.view<VelocityComponent>();
    auto tobDisplaced = sRegistry.view<DisplaceComponent>();

//    while (tobDisplaced.size() > 0 || velocomps.size() > 0 || i > 5) {
        for (auto  entity : velocomps){
            auto [t, v, d] = sRegistry.try_get<TransformComponent, VelocityComponent, DisplaceComponent>(entity);
            //TODO: check for collisions, bounding entswCollision, noclip, etc
            //maybe kinetic comp instead of velo? velo and acc in one?
            if (d){
                d->displace += v->velocity.pos;
                t->trans.scale += v->velocity.scale;
                d->displace += v->velocity.rotation;
            
            } else {
                sRegistry.emplace<DisplaceComponent>(entity, v->velocity.pos, v->velocity.rotation.z);
            }
        }
        //DISPLACE
        //TB MEANS TO BE DISPLACED
        //E MEANS ENVIRONMENTAL (ENTS GATHERED FROM SCENE IN SURROUNDINGS)
    auto entswCollision = sRegistry.view<BoxComponent>();

        for (auto  etobDisplaced : tobDisplaced){
                    auto [transTB, dispTB, boxTB] = sRegistry.try_get<TransformComponent, DisplaceComponent, BoxComponent>(etobDisplaced);
                    //TODO: check for collisions, bounding entswCollision, noclip, etc
                    if (transTB && boxTB){
                        bool free = true;
                        bool deflect = false;
                        glm::vec2 callertoObj;
                        glm::vec3 deflection;
                        int i = 0;
                        cout << endl;
                        while (dispTB && i < 1) {
                            for (auto entwCollision : entswCollision){
                                if (entwCollision != etobDisplaced){
                                    auto [transE, boxE] = sRegistry.try_get<TransformComponent, BoxComponent>(entwCollision);
                                    glm::vec3 callerBoxCenter = glm::vec3(transTB->trans.pos.x + boxTB->pos.x,
                                                                          transTB->trans.pos.y + boxTB->pos.y,
                                                                          transTB->trans.pos.z);
                                    glm::vec3 objBoxCenter = glm::vec3(transE->trans.pos.x + boxE->pos.x,
                                                                       transE->trans.pos.y + boxE->pos.y,
                                                                       transE->trans.pos.z);
                                    callertoObj = glm::vec2(objBoxCenter.x - callerBoxCenter.x, objBoxCenter.y - callerBoxCenter.y);
                                    float collangle = glm::degrees(fmath::vectorToAngle(glm::vec3(callertoObj, 0.0)));
                                    float dispangle = glm::degrees(fmath::vectorToAngle(dispTB->displace));
                                    float colltoDisp = fmath::smallestAngleFrom(collangle,
                                                                                dispangle);
                                        //TODO: all of these need to filter entities to collide check to within specified range which will be max boxcomp size to avoid looping over entities across the world from each other
                                    if (boxTB->type == 'c' && boxE->type == 'c'){
    //BOX TO BE AND BOX ENVIRONMENT ARE BOTH RADIAL, CHECK ACCORDINGLY
                                        bool cc = (glm::length((callerBoxCenter + dispTB->displace) - objBoxCenter) - boxE->rad - boxTB->rad) < 0;
                                        if (cc){
                                            free = false;
                                            int sign = 1;
                                            if (colltoDisp < 0) {sign = -1;}
                                            glm::vec3 V = fmath::angleToVector(collangle + (90 * sign));
                                            float udotv = (dispTB->displace.x * V.x) + (dispTB->displace.y * V.y);
                                            float magvsq = glm::length(V) * glm::length(V);
                                            deflection = V * (udotv / magvsq);
                                                //TODO: check deflect against all other ents once more
                                            deflect = true;
                                        }
                
                                    } else if (boxTB->type == 'c' && boxE->type == 's') {
    //BOX TO BE IS RADIAL, BOX E IS RECTANGULAR, CHECK ACCORDINGLY
                                        auto objToCaller = (callertoObj * -1.0f) + glm::vec2(dispTB->displace.x, dispTB->displace.y);
                                        glm::vec3 objToCaller_r = glm::vec3(fmath::rotateVector(objToCaller, -transE->trans.rotation.z), 0.0);
//                                        bool cs = ((glm::abs(objToCaller_r.x) <= ((boxE->size.x / 2.0) + (boxTB->rad / 1.41))) &&
//                                                    (glm::abs(objToCaller_r.y) <= ((boxE->size.y / 2.0) + (boxTB->rad / 1.41))));
                                        Collision coll(this, etobDisplaced);
                                        coll.Check(entwCollision);
                                        bool cs = coll.overlap();
                                        cout << "overlap according to coll: ";
                                        if (cs){cout << "TRUE\n";} else if (!cs) { cout << "FALSE\n";}
                
                                        if (cs){
                                            free = false;
                                            //deflect...
                                            deflect = true;
                                            glm::vec3 V;
                                            bool hittingWSide = (((boxE->size.x / 2.0) + boxTB->rad)) - (glm::abs(objToCaller_r.x)) <
                                            (((boxE->size.y / 2.0) + boxTB->rad)) - (glm::abs(objToCaller_r.y));
                                            bool hittingHSide = (((boxE->size.x / 2.0) + boxTB->rad)) - (glm::abs(objToCaller_r.x)) >
                                            (((boxE->size.y / 2.0) + boxTB->rad)) - (glm::abs(objToCaller_r.y));
                                            
                                            
                                            float sidehit = ((((boxE->size.x / 2.0) + boxTB->rad)) - (glm::abs(objToCaller_r.x))) -
                                            ((((boxE->size.y / 2.0) + (boxTB->rad))) - (glm::abs(objToCaller_r.y)));
                                            cout << "sidehit = " << sidehit << endl;
                                            deflection = glm::vec3(0.0);
                                            float thresh = boxTB->rad;
                                            
                                            glm::vec2 normal;
                                            if (hittingWSide){
                                                if (objToCaller_r.x < 0){
                                                    normal = glm::vec2(-1.0, 0.0);
                                                    normal = fmath::rotateVector(normal, transE->trans.rotation.z);
                                                } else {
                                                    normal = glm::vec2(1.0, 0.0);
                                                    normal = fmath::rotateVector(normal, transE->trans.rotation.z);
                                                }
                                            } else {
                                                if (objToCaller_r.y < 0){
                                                    normal = glm::vec2(0.0, -1.0);
                                                    normal = fmath::rotateVector(normal, transE->trans.rotation.z);
                                                } else {
                                                    normal = glm::vec2(0.0, 1.0);
                                                    normal = fmath::rotateVector(normal, transE->trans.rotation.z);
                                                }
                                            }
                                            
                                            
                                            bool pointingAway = glm::abs(fmath::smallestAngleFrom(glm::degrees(fmath::vectorToAngle(dispTB->displace)), glm::degrees(fmath::vectorToAngle(normal)))) < 90.0;
                                            
                                            if (pointingAway){
                                                V = fmath::angleToVector(glm::degrees(fmath::vectorToAngle(dispTB->displace)) + 90.0);
                                                free = true;
                                                deflect = false;
                                            } else if (hittingWSide){//sidehit < -thresh){
                                                V = glm::vec3(0.0, (-2.0 * (objToCaller_r.x < 0)) + 1.0, 0.0);
                                                V = fmath::rotateVector(V, transE->trans.rotation.z);
                                                cout << "V: " << V.x << ", " << V.y << endl;
                                                float udotv = (dispTB->displace.x * V.x) + (dispTB->displace.y * V.y);
                                                deflection = V * udotv;
                                            } else if (hittingHSide){//sidehit > thresh){
                                                V = glm::vec3((-2.0 * (objToCaller_r.y < 0)) + 1.0, 0.0, 0.0);
                                                V = fmath::rotateVector(V, transE->trans.rotation.z);
                                                cout << "V: " << V.x << ", " << V.y << endl;
                                                float udotv = (dispTB->displace.x * V.x) + (dispTB->displace.y * V.y);
                                                deflection = V * udotv;
                                            } else {
                                                V = fmath::angleToVector(glm::degrees(fmath::vectorToAngle(dispTB->displace)) + 90.0);
                                                free = true;
                                                deflect = false;
                                            }
//                                            V = fmath::rotateVector(V, transE->trans.rotation.z);
//                                            cout << "V: " << V.x << ", " << V.y << endl;
//                                            float udotv = (dispTB->displace.x * V.x) + (dispTB->displace.y * V.y);
//                                            deflection = V * udotv;
//                                            cout << "deflection: " << deflection.x << ", " << deflection.y << "\n";
                                            sDiags["deflect"] = glm::degrees(fmath::vectorToAngle(deflection));
                                            cout << "def angle: " << glm::degrees(fmath::vectorToAngle(deflection)) << ", deflect = " << deflect << endl;
//                                            cout << "\nV angle: " << glm::degrees(fmath::vectorToAngle(deflection));
                                            cout << "disp angle: " << glm::degrees(fmath::vectorToAngle(dispTB->displace)) << endl << endl;
//                                            cout << "\nabs(V - disp): " << glm::abs(glm::degrees(fmath::vectorToAngle(deflection)) -
//                                                                                    glm::degrees(fmath::vectorToAngle(dispTB->displace))) << endl << endl;
//                                            if (glm::abs(glm::degrees(fmath::vectorToAngle(deflection)) -
//                                                         glm::degrees(fmath::vectorToAngle(dispTB->displace))) <= 180.0){
//                                                deflect = true;
//                                            }
//                                            float maintodeflec = fmath::smallestAngleFrom((glm::degrees(fmath::vectorToAngle(objToCaller_r * -1.0f))),
//                                                                     (glm::degrees(fmath::vectorToAngle(deflection))));
//                                            cout << "maintodeflec = " << maintodeflec << endl;
//                                            float maintodisp = fmath::smallestAngleFrom((glm::degrees(fmath::vectorToAngle(objToCaller_r * -1.0f))),
//                                                                     (glm::degrees(fmath::vectorToAngle(dispTB->displace))));
//                                            cout << "maintodisp = " << maintodisp << endl;
//
//                                            bool samesign = ((maintodeflec * maintodisp) > 0);
//                                            bool deflecbigger = (glm::abs(maintodeflec) >= glm::abs(maintodisp));
//                                            bool x = samesign && deflecbigger;
//                                            if (x){
//                                                deflect = true;
//                                            } else {
//                                                free = true;
//                                            }
                                        }
                
                                    } else if   (boxTB->type == 's' && boxE->type == 's') {
    //BOX TO BE AND BOX E ARE BOTH RECTANGULAR, CHECK ACCORDINGLY
                
                                    } else if (boxTB->type == 's' && boxE->type == 'c') {
    //BOX TO BE IS RECTANGULAR, BOX E IS RADIAL, CHECK ACCORDINGLY
                                    }

                                }
            
                            }
                            i++;
                            if (deflect) {
                                sRegistry.replace<DisplaceComponent>(etobDisplaced, deflection);
                            }
                        }
                        if (true){
                            transTB->trans.pos += (dispTB->displace);
//                            cout << "in free, " << dispTB->displace.x << " , " << dispTB->displace.y << endl;
                        }
                    }
                    sRegistry.remove<DisplaceComponent>(etobDisplaced);

        }
        
    
}

void Scene::Camera(float dt){
    //TODO: only works w orthos rn
    //look through all cameras w tforms to get an enabled one
    //camera MUST HAVE TFORM to be considered here
    //TODO: enable(cameracomp cam) func somewhere
    auto validCameras = sRegistry.group<OrthoCameraComponent>(entt::get<TransformComponent>);
    for (entt::entity cam : validCameras){
        bool flag = false;
        //check if active
        const auto&[cameraComp, transformComp] = validCameras.get<OrthoCameraComponent, TransformComponent>(cam);
        if (cameraComp.enable){  //TODO: set up entt observer to check this so that currcam changes only up when necc (probly rare)
            currCam = cam;
            flag = true;
        }
        if (!flag){
            cout << "no valid camera enabled in current scene registry!\n";
        }
        auto [currCamT, currCamC] = sRegistry.get<TransformComponent, OrthoCameraComponent>(currCam);
        //link cam and trans
        currCamC.pos = currCamT.trans.pos;
        
        glm::vec3 target = currCamC.pos + currCamC.look;
        currCamC.view = lookAt(currCamC.pos, target, currCamC.up);
        
        glm::vec2 orthoDims = glm::vec2(currCamC.viewWidth, currCamC.viewWidth / window.aspect);

        glm::vec4 lrbt = (lrbtMat * orthoDims);

        orthoDims.y = orthoDims.x / window.aspect;
        lrbt = (lrbtMat * orthoDims);
        currCamC.proj = glm::ortho(lrbt.x, lrbt.y, lrbt.z, lrbt.w, currCamC.near, currCamC.far);

        //UPLOAD VIEWS AND PROJS TO ALL SHADERS
        currCamProj = currCamC.proj;
        currCamView = currCamC.view;
        currCamPos = currCamC.pos;
        currCamWorldFrame = orthoDims;
        //TODO: organize which shaders get what
        
//        for (auto shad : sShaders){
//            shad.second.bind();
//            shad.second.uMat4("uView", currCamC.view);
//            shad.second.uMat4("uProj", currCamC.proj);
//        }
        
       
        sShaders["default"].bind();
        sShaders["default"].uMat4("uView", currCamC.view);
        sShaders["default"].uMat4("uProj", currCamC.proj);
        
        glm::mat4 viewUI = lookAt(glm::vec3(0.0, 0.0, 10.0), glm::vec3(0.0), glm::vec3(0.0, 1.0, 0.0));
        glm::mat4 projUI = glm::ortho((-2.0),
                                      (2.0),
                                      (-2.0 / window.aspect),
                                      (2.0 / window.aspect),
                                      0.0001,
                                      1000.0);
        sShaders["UI"].bind();
        sShaders["UI"].uMat4("uView", viewUI);
        sShaders["UI"].uMat4("uProj", projUI);


        

    }

}

void Scene::DrawSystemRender(){
    auto validRenders = sRegistry.group<MeshComponent>(entt::get<TransformComponent,
                                                                 DrawOrderComponent,
                                                                 TextureComponent,
                                                                 ShaderComponent>);
    for (int i = 0; i < 9; i++){
        for(auto entity : validRenders){
            //DEBUG: this doesnt check if any valid renders present and will bad access in that case
            auto [mesh, trans, order, tex, shad] = validRenders.get(entity);
            if (order.priority == i){
                sShaders[shad].bind();
                sShaders[shad].uVec2("uRes", window.frame);
//                sShaders[shad].uFloat("uTime", window.time);
                sShaders[shad].uVec2("uMouse", window.mouse.position);
                sShaders[shad].uMat4("uModel", glm::scale(genModelMat(trans.trans),
                                                          glm::vec3(tex.spritePixW / 16.0,
                                                                    tex.spritePixH / 16.0,
                                                                    1.0)));
                sShaders[shad].uInt("uTexture", tex.slot);
                sShaders[shad].uInt("uSpritePixW", tex.spritePixW);
                sShaders[shad].uInt("uSpritePixH", tex.spritePixH);
                sShaders[shad].uVec2("uSpriteSheetCoords", tex.sheetPos);
          
                DrawMesh(&mesh.mesh);
            }
        }
    }
}

glm::vec3 Scene::mouseToWorldSpace(glm::vec2 pm){
    glm::vec3 pworld;
    glm::vec2 pmouse = pm;
    pmouse.x /= window.frame.x;
    pmouse.x *= 2;
    pmouse.x -= 1;
    pmouse.y /= window.frame.y;
    pmouse.y *= 2;
    pmouse.y -= 1;
    pmouse.y *= -1;
    
    pworld.x = currCamPos.x + (pmouse.x * (currCamWorldFrame.x / 2));
    pworld.y = currCamPos.y + (pmouse.y * (currCamWorldFrame.y / 2));
//    cout << pworld.x << ", " << pworld.y << "\n";

    
    return pworld;
}
glm::vec2 Scene::worldToMouseSpace(glm::vec3 pworld){
    glm::vec2 pmouse;
    glm::mat4 model = genModelMat(Transform(pworld));
    pmouse = currCamProj * (currCamView * (model * vec4(pworld, 1.0f)));
    pmouse.x = (pmouse.x + 1) / 2;
    pmouse.y = (pmouse.y + 1) / 2;
    pmouse.x *= window.frame.x;
    pmouse.y *= window.frame.y;
    return pmouse;
}

glm::vec2 Scene::worldToScreenSpace(glm::vec3 pworld){
    glm::vec2 pscreen;
    glm::mat4 model = genModelMat(Transform(pworld));
    pscreen = currCamProj * (currCamView * (model * vec4(pworld, 1.0f)));
    return pscreen;
}

glm::vec3 Scene::screenToWorldSpace(glm::vec2 s){
    glm::vec3 pworld;
    glm::vec2 pscreen = s;
//    pscreen.x /= window.frame.x;
//    pscreen.x *= 2;
//    pscreen.x -= 1;
//    pscreen.y /= window.frame.y;
//    pscreen.y *= 2;
//    pscreen.y -= 1;
//    pscreen.y *= -1;
    
    pworld.x = currCamPos.x + (pscreen.x * (currCamWorldFrame.x / 2));
    pworld.y = currCamPos.y + (pscreen.y * (currCamWorldFrame.y / 2));
//    cout << pworld.x << ", " << pworld.y << "\n";

    
    return pworld;
}

//void removePointerComponent(entt::registry &reg, entt::entity ent){
////    auto pcomp
//}

entt::entity Scene::getEntityID(string name){
    return sEnts[name]->getID();
}




